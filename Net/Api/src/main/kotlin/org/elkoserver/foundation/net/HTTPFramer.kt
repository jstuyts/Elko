package org.elkoserver.foundation.net

import org.elkoserver.util.trace.Trace

/**
 * An HTTPFramer is responsible for extracting messages from HTTP POSTs
 * arriving on an HTTP connection and doing something meaningful with them.  It
 * is also responsible for actually producing the HTTP replies that will be
 * transmitted in response to HTTP requests sent to the server.
 *
 *
 * The base HTTPFramer treats the content of each HTTP POST (to the /xmit/
 * URL) as a simple string being delivered to the server.
 */
abstract class HTTPFramer
/**
 * Constructor.
 *
 * @param myMsgTrace  Trace object for logging message traffic.
 */ protected constructor(private val myMsgTrace: Trace) {

    /**
     * Produce the HTTP reply body for responding to an unrecognized URL (that
     * is, a 404 error).
     *
     * @param badURL  The URL that was no good.
     *
     * @return an appropriate HTTP reply body string to accompany the 404
     * error that will be returned.
     */
    fun makeBadURLReply(badURL: String): String {
        /* Error haiku, see http://www.c4vct.com/kym/humor/haikus.htm */
        return """<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>404 Not Found</title>
</head><body>
<h1>Not Found</h1>
The requested URL $badURL was not found here.
<p><hr><p>The web site you seek<br>
cannot be located but<br>
endless others exist<p>
</body></html>

"""
    }

    /**
     * Produce the HTTP reply body containing the JSON string for responding to
     * an HTTP GET or POST of the /connect/ URL.
     *
     * @param sessionID  The session ID number for the session.
     *
     * @return an appropriate HTTP reply body JSON string for responding to a
     * /connect/ request that created the given session.
     */
    fun makeConnectReply(sessionID: Long): String {
        return "{ \"sessionid\": \"$sessionID\" }\n"
    }

    /**
     * Produce the HTTP reply body containing the JSON string for responding to
     * an HTTP GET or POST of the /disconnect/ URL.
     *
     * @return an appropriate HTTP reply body string for responding to a
     * /disconnect/ request.
     */
    fun makeDisconnectReply(): String {
        return "{ }\n"
    }

    /**
     * Produce a fragment of the HTTP reply body containing JSON messages in
     * response to an HTTP GET or POST of the /select/ URL.  This JSON text
     * will either deliver a message (or messages) to the client or inform the
     * client that there are no messages at this time.
     *
     *
     * This method is able to produce fragmentary output to support packing
     * multiple messages into a single reply body: the reply consists of a
     * prefix, the actual encoding of the message(s) being sent, and then a
     * suffix.  The prefix is only produced if the 'start' parameter is true;
     * likewise for the suffix and the 'end' parameter.  It is possible to
     * concatenate the fragments generated by any number of calls to this
     * method to produce a valid reply body, so long as the 'start' parameter
     * is set on the first call (and not the others), and the 'end' parameter
     * is set on the last call (and not the others).
     *
     * @param message  The message to be sent, or null if no messages are to be
     * sent.
     * @param seqNumber  The sequence number for the next select request.
     * @param start  true if this message is the first in a batch.
     * @param end  true if this message is the last in a batch.
     *
     * @return an appropriate HTTP reply body JSON fragment string for
     * responding to a /select/ by delivering 'message' to the client.
     */
    open fun makeSelectReplySegment(message: Any?, seqNumber: Int, start: Boolean, end: Boolean): String {
        var result = ""
        result += if (start) {
            "{ \"msgs\": ["
        } else {
            ", "
        }
        if (message != null) {
            result += "" + message
        }
        if (end) {
            result += "], \"seqnum\": \"$seqNumber\" }\n"
        }
        return result
    }

    /**
     * Produce the HTTP reply body containing the JSON string for responding to
     * an HTTP GET or POST where the URL that was presented to the server had
     * an out-of-sequence sequence number or a bad session ID number.
     *
     * @param error  Error string to transmit.
     *
     * @return an appropriate HTTP reply body JSON string for responding to a
     * URL with a bad sequence number.
     */
    fun makeSequenceErrorReply(error: String): String {
        return "{ \"error\": \"$error\" }\n"
    }

    /**
     * Produce the HTTP reply body containing the JSON string for responding to
     * an HTTP GET or POST of the /xmit/ URL used to transmit messages from the
     * client to the server.
     *
     * @param seqNumber  The sequence number for the next xmit request.
     *
     * @return an appropriate HTTP reply body JSON string for responding to a
     * POST or GET delivering messages to the server.
     */
    fun makeXmitReply(seqNumber: Int): String {
        return "{ \"seqnum\": \"$seqNumber\" }\n"
    }

    /**
     * Get the message trace object for this framer.  This trace object should
     * only be used for logging the content of message traffic.  Other server
     * events should be logged to Trace.comm.
     *
     * @return this framer's message trace object.
     */
    fun msgTrace(): Trace {
        return myMsgTrace
    }

    /**
     * Return an iterator that will return the application-level message or
     * messages (if any) in the body of a received HTTP POST.
     *
     * @param postBody  The HTTP POST body in question.
     *
     * @return an iterator that can be called upon to return the application-
     * level message(s) contained within 'postBody'.
     */
    abstract fun postBodyUnpacker(postBody: String): Iterator<Any>

}